<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt" xml:lang="pt">
<head>
<!-- 2017-09-27 qua 01:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clube de Programação</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Leandro Zatesko, João Paulo Castilho" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="https://urionlinejudge.r.worldssl.net/repository/contest.css" />
<style type="text/css"> p{ margin-top: 1em; margin-bottom: 1em; } </style>
<script type="text/javascript" src="org-info.js">
/**
 *
 * @source: org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in org-info.js.
 *
 * Copyright (C) 2012-2017 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "overview");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Clube de Programação
<br />
<span class="subtitle">Repositório de Dicas para Problemas</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd84a7ac">1. DICAS GERAIS</a></li>
<li><a href="#org450b3c9">2. URI 2006 Identifying Tea</a></li>
<li><a href="#org29391ea">3. URI 1961 Jumping Frog</a></li>
<li><a href="#orge3a0758">4. URI 1847 Welcome to the Winter!</a></li>
<li><a href="#org030abf8">5. URI 1563 The Big Problem</a></li>
<li><a href="#org0e1b512">6. URI 1137 Cocircular Points</a></li>
<li><a href="#org80a3874">7. URI 1863 Ramsay's Counter-attack</a></li>
<li><a href="#orgb858c86">8. URI 1753 Knights Of The Round Table</a></li>
<li><a href="#orgc024212">9. URI 1491 Blogger Language</a></li>
<li><a href="#org80fdf9f">10. URI 1427 The Scrooge Co Problem</a></li>
<li><a href="#orgdd9a4d1">11. URI 1915 Help Chaves</a></li>
<li><a href="#org58cf566">12. UVA 13018 Dice Cup</a></li>
<li><a href="#org08c88b2">13. UVA 13025 Back to the Past</a></li>
<li><a href="#org4ccf7ab">14. UVA 665 False Coins</a></li>
<li><a href="#org250517b">15. UVA 12005 Bubble Sort</a></li>
<li><a href="#org2c68688">16. UVA 11048 Automatic Correction of Misspellings</a></li>
<li><a href="#orgde115a2">17. UVA 10739 String to Palindrome</a></li>
<li><a href="#org183780b">18. UVA 10192 Vacation</a></li>
<li><a href="#org50d80f2">19. UVA 11258 String Partition</a></li>
<li><a href="#org600fcf7">20. UVA 10891 Game of Sum</a></li>
<li><a href="#orgddc0526">21. UVA 11610 Reverse Prime</a></li>
<li><a href="#org7400792">22. URI 1634 Another Lottery</a></li>
<li><a href="#orgf1c9bbd">23. URI 2014 Blood Groups</a></li>
<li><a href="#org9e57a43">24. URI 1671 Code</a></li>
<li><a href="#org69a9ea6">25. URI 1748 Fence the Vegetables</a></li>
<li><a href="#orge81f37b">26. URI 2007 Fence the Vegetables Fail</a></li>
<li><a href="#orge1ecebf">27. URI 2012 Height Map</a></li>
<li><a href="#orgfd860a9">28. URI 1752 Journey Through The Kingdom</a></li>
<li><a href="#org47a9dcb">29. URI 2009 Just a bit sorted</a></li>
<li><a href="#org76e6bd2">30. URI 2030 Pit Stop</a></li>
<li><a href="#org93e6f58">31. URI 2031 Rock, Paper, Airstrike</a></li>
<li><a href="#orgd4a4355">32. UVA 13049 Combination Lock</a></li>
<li><a href="#org6e9c299">33. UVA 11094 Continents</a></li>
<li><a href="#org2c7fddb">34. UVA 11357 Ensuring Truth</a></li>
<li><a href="#org847d02c">35. UVA 11475 Extend to Palindromes</a></li>
<li><a href="#org9d73e04">36. UVA 622 Grammar Evaluation</a></li>
<li><a href="#org7bfae97">37. UVA 10859 Placing Lampposts</a></li>
<li><a href="#orgb5587c7">38. UVA 12542 Prime Substring</a></li>
<li><a href="#orgcd2fb98">39. UVA 13026 Search the Khoj</a></li>
<li><a href="#orgdf002a9">40. UVA 11319 Stupid Sequence?</a></li>
<li><a href="#org71afe5f">41. UVA 488 Triangle Wave</a></li>
<li><a href="#orgeb4c262">42. LA 5057 Worst Location</a></li>
<li><a href="#org5dd742c">43. LA 5058 Counting BST</a></li>
<li><a href="#orga6cce4c">44. LA 5059 Playing With Stones</a></li>
<li><a href="#org568f31b">45. LA 5060 Arm Wrestling Tournament</a></li>
<li><a href="#org6b8f597">46. LA 5061 Lightning Energy Report</a></li>
<li><a href="#org73c2e10">47. LA 5062 Transitive Closure</a></li>
<li><a href="#org71ef16d">48. LA 5063 Just Sum It</a></li>
<li><a href="#orgea9151f">49. LA 5064 Serial Numbers</a></li>
<li><a href="#org8906335">50. LA 5065 Romantic Date</a></li>
<li><a href="#org789e22d">51. LA 5066 Fire Drill</a></li>
<li><a href="#orgd6aafee">52. URI 1912 Help Seu Madruga</a></li>
<li><a href="#org8525a8d">53. URI 1856 Arya's Death List</a></li>
<li><a href="#org6e8aebb">54. URI 1852 Stark Direwolves</a></li>
<li><a href="#orge2ee33d">55. LA 7580 Forever Young</a></li>
<li><a href="#orgb0a6e02">56. CF 670D{1, 2} Magic Powder</a></li>
<li><a href="#org60bff93">57. URI 2036 Efeito Dominó</a></li>
<li><a href="#orge47a13d">58. URI 2351 Hotel Rewards</a></li>
<li><a href="#org13acbde">59. URI 2349 Farm Robot</a></li>
<li><a href="#org3bde193">60. URI 1034 Ice Statues Festival</a></li>
<li><a href="#orgdf0a60c">61. URI 1152 e UVa 11631 Dark Roads</a></li>
<li><a href="#org1585308">62. URI 2531 Shopping in FdI</a></li>
</ul>
</div>
</div>
<p>
y# -<b>- coding: utf-8 after-save-hook: (lambda nil (org-html-export-to-html)) -</b>-
</p>
<p>
Os problemas a seguir não estão ordenados nem lexicográfica nem
numericamente, mas por ordem de inclusão neste arquivo. Utilize as
ferramentas de seu navegador para localizar as dicas para um problema
específico.
</p>

<p>
Achou algum erro ou tem alguma consideração sobre alguma coisa nesta
página? Mande-nos um <a href="mailto:jpwbernardi@hotmail.com">email</a>.
</p>

<p>
Esta página foi desenvolvida com o <a href="http://orgmode.org/">Org Mode</a> do <a href="https://www.gnu.org/software/emacs/">Emacs</a>.
</p>

<div id="outline-container-orgd84a7ac" class="outline-2">
<h2 id="orgd84a7ac"><span class="section-number-2">1</span> DICAS GERAIS</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Pratique muito, tanto sozinho quanto com seu time! Nada de "dividir"
os tópicos entre os membros do time! Todos precisam ser bons em
tudo, ou o time não conseguirá compor soluções que envolvem vários
conteúdos! Você precisa desenvolver suas habilidades de codar rápido
e codar certo.</li>

<li>Nos treinos, simule todas as condições da competição. Que o time use
só uma máquina para codar, e outras máquinas só para ler os
problemas, e que o material de consulta seja apenas o impresso (já
vá organizando seu caderninho!)</li>

<li>Nunca ocupe a máquina se você não tem uma solução completamente
pronta (esboçada no papel ou na sua cabeça) para codar, com a
garantia de que ela está correta e de que tem a complexidade
esperada (dimensionar o quanto sua solução vai consumir de tempo e
de memória é importantíssimo! não perca tempo codando algo
impossível de passar no time limit!)</li>

<li>É estratégia dominante para minimizar a soma dos tempos das
submissões aceitas (e, portanto, maximizar o número de problemas
passados na prova) resolver primeiro os problemas mais fáceis (ou
melhor, que o time leva menos tempo para passar). Então, comecem
cada um trabalhando num problema diferente, revezando-se no uso da
máquina, e deixem para concentrar esforços de dois ou mais
integrantes trabalhando num só problema mais para o final da
prova. No começo, pegue cada um uma parte da prova para ler e achar
rápido os problemas mais fáceis. Fique também sempre atento ao
placar, para ver o que os outros times estão resolvendo (isso pode
ser um indicativo de quais são os problemas mais fáceis!)</li>

<li>Após não conseguir resolver um problema na competição ou no treino,
estude o conteúdo referente àquele problema durante a semana e tente
novamente até conseguir passá-lo. Perseverar é importantíssimo.</li>

<li>O ideal é ter um treino zerado antes do próximo treino. Se acontecer
de ficarem alguns problemas para trás, foque primeiro nos problemas
do treino corrente, depois ponha sua lição de casa em dia.</li>

<li>Devore livros e materiais específicos de Programação Competitiva,
especialmente <a href="http://cpbook.net/">este livro</a>.</li>

<li>Não leia as dicas de um problema sem antes refletir sobre o problema
o suficiente. Se você treina no sábado, sugiro pelo menos no domingo
ainda tentar resolver os problemas sem as dicas. Abra as dicas
apenas na segunda-feira, e olhe códigos na Internet apenas em último
caso ;)</li>

<li>Após passar um problema, veja códigos na Internet e dos seus colegas
que também passaram um problema para ver como você poderia ter feito
diferente (mais simples, mais curto, mais elegante, menos propenso a
bugs).</li>

<li><p>
Não seja malloqueiro! Deixe a STL do C++ cuidar da alocação dinâmica
para você quando precisar dela! Desenvolva práticas de código que
ajudem no debug, se você precisar! Algumas sugestões:
</p>

<p>
&#x2013; Escreva uma função do começo ao fim, deixando para implementar as
subrotinas depois.
</p>

<p>
&#x2013; Modularize seu código para que as funções sejam curtas, bem
escritas, sem precisar de comentários para serem legíveis, e sem um
número exagerado de níveis de indentação.
</p>

<p>
&#x2013; Jamais escreva uma porção de código que faz a mesma coisa
trocando apenas os papéis das variáveis. Estruture melhor suas
macros e os cabeçalhos das funções então (e.g. movimentos das peças
do xadrez!)
</p>

<p>
&#x2013; Defina constantes no cabeçalho do código, ao invés de colocar
números absolutos nas funções.
</p>

<p>
&#x2013; Use alocação estática sempre que puder, e sempre com folga nos
tamanhos dos arrays.
</p>

<p>
&#x2013; Trabalhe com inteiros sempre que puder, tomando sempre o cuidado
com somas e produtos acumulados (eles cabem em 32 bits?)
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org450b3c9" class="outline-2">
<h2 id="org450b3c9"><span class="section-number-2">2</span> URI 2006 Identifying Tea</h2>
<div class="outline-text-2" id="text-2">
<p>
Dispensa dicas.
</p>
</div>
</div>

<div id="outline-container-org29391ea" class="outline-2">
<h2 id="org29391ea"><span class="section-number-2">3</span> URI 1961 Jumping Frog</h2>
<div class="outline-text-2" id="text-3">
<p>
Dispensa dicas.
</p>
</div>
</div>

<div id="outline-container-orge3a0758" class="outline-2">
<h2 id="orge3a0758"><span class="section-number-2">4</span> URI 1847 Welcome to the Winter!</h2>
<div class="outline-text-2" id="text-4">
<p>
Dispensa dicas. Só tome cuidado para ler o problema e garantir que
você interpretando os casos corretamente ;)
</p>
</div>
</div>

<div id="outline-container-org030abf8" class="outline-2">
<h2 id="org030abf8"><span class="section-number-2">5</span> URI 1563 The Big Problem</h2>
<div class="outline-text-2" id="text-5">
<p>
Se fixamos um \(N\) e um \(A\in\{1,N\}\), o número de pares \((A,B)\) tais
que \(B>1\) e \(B\leq N\mathbin{\text{mod}} A\) é obviamente
\(N\mathbin{\text{mod}} A\). Então, o que o problema pede, dado \(N\), é
simplesmente a fração \(\rho(N)/N^2\), simplificada usando o
<a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Algoritmo de Euclides</a>
(Cuidado, porque a resposta pode não caber em 32 bits!),
sendo
\(\rho(N)=\sum_{i=1}^N(N\mathbin{\text{mod}} i)\). Como
\(N\leq 10^8\), computar \(S(N)\) de um modo ingênuo é inviável, mesmo
que a entrada consistisse de um só caso de teste. Vamos precisar
manipular \(\rho(N)\) um pouco.
</p>

<p>
Primeiro observemos que
\((N\mathbin{\text{mod}} i) - ((N-1)\mathbin{\text{mod}} i)\) é:
\(1\), se \(i\) não
divide \(N\); \(1-i\), caso contrário. Assim, tentando estabelecer uma
recorrência para \(\rho(N)\) (lembrando que \(\sigma(N)\) é a soma dos
divisores de \(N\)):
</p>

\begin{gather*}
\rho(N)-\rho(N-1) = \sum_{i\text{ não divisor de }N}1
+\sum_{i\text{ divisor próprio de }N}(1-i)
= \sum_{i=1}^{N-1}1-\sum_{i\text{ divisor próprio de }N}i\\
= N - 1 - \sum_{i\text{ divisor de }N}i + N = 2N - 1 - \sigma(N)
\end{gather*}

<p>
Então, a recorrência é:
\(\rho(N) = 2N-1-\sigma(N)+\rho(N - 1)\). Resolvendo:
</p>

\begin{equation*}
\rho(N) = \sum_{i=1}^N(2i-1-\sigma(i))
=2\sum_{i=1}^Ni-N-\sum_{i=1}^N\sigma(i)=N^2-\sum_{i=1}^N\sigma(i)
\end{equation*}

<p>
Então, nosso problema agora se resume a computar
\(\sum_{i=1}^N\sigma(i)\). Uma vez computada essa soma, podemos obter
\(\rho(N)\) em \(O(1)\). Deixo a cargo de vocês agora
<a href="http://mathoverflow.net/questions/195325/how-to-calculate-the-sum-of-remainders-of-n">pesquisar</a> como
calcular essa soma em tempo \(O(\sqrt N)\) ;)
</p>

<ul class="org-ul">
<li>Complexidade: \(O(\sqrt N)\)</li>
</ul>
</div>
</div>

<div id="outline-container-org0e1b512" class="outline-2">
<h2 id="org0e1b512"><span class="section-number-2">6</span> URI 1137 Cocircular Points</h2>
<div class="outline-text-2" id="text-6">
<p>
O que o problema pede, dado um conjunto de pontos, é o maior número de
pontos que são cocirculares. O que se deve ter em mente é que cada
conjunto de pontos não-colineares (podemos verificar facilmente se
três
pontos são colineares através de produto vetorial) define uma única
circunferência.
Então, iterando sobre todos os conjuntos de três pontos
não-colineares, podemos simplesmente adicionar ao final de um vetor a
circunferência definida
por estes três pontos. No final, ordenando o vetor,
podemos verificar que, se uma mesma circunferência
aparecer \(k\) vezes no vetor, podemos obter o número \(p\) de pontos da
entrada
que
pertencem a esta circunferência através da equação \(k=\binom p3\) (dica
extra pra resolver a equação: busca na 3<sup>a</sup>
coluna do Triângulo de Pascal).
</p>

<ul class="org-ul">
<li>Complexidade: como no pior caso cada tripla de pontos pode definir
uma circunferência distinta, \(O(N^3\log N)\). Embora eu mesmo tenha
submetido um código \(O(N^4)\) no URI (não meu) e passado :P</li>
</ul>
</div>
</div>

<div id="outline-container-org80a3874" class="outline-2">
<h2 id="org80a3874"><span class="section-number-2">7</span> URI 1863 Ramsay's Counter-attack</h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
<i>Dicas escritas pelo Prof. Ricardo Oliveira, autor do problema.</i>
</p>
</blockquote>

<p>
O problema pode ser resolvido por programação dinâmica. Cada estado consiste
apenas de um soldado \([u]\), e responde o tamanho da maior sequência terminando
nele. Seu cálculo é dado por \(1 + \max(PD[u'])\), onde \(u'\) é um soldado posicionado a
sudoeste de \(u\) e é mais forte que \(u\).
</p>

<p>
Entretanto, o cálculo de cada estado não pode ser feito em tempo
linear em \(N\), uma vez que isto tornaria todo o algoritmo
quadrático em \(N\).
</p>

<p>
Entretanto, é possível manter um conjunto \(S\), tal que, quando o
estado \([u]\)
for
visitado, \(S\) contém exatamente todos os soldados mais fortes que
\(u\). Para tal, é
possível inverter o grafo dado (i.e. criar um arco \(i\to j\) quando \(i\)
é mais fraco
que \(j\)).
Note que este grafo é uma floresta. É feita então uma busca em
profundidade (DFS).
Quando o vértice \(u\) for visitado, o conjunto \(S\)
será dado pelos vértices atualmente
na pilha. Logo, um vértice deve ser incluído em \(S\)
ao ser empilhado, e removido de
\(S\) ao ser desempilhado.
</p>

<p>
Por fim, é necessário, em cada estado \([u]\),
consultar os vértices que estão em \(S\)
e que estão a sudoeste de \(u\).
Isto pode ser feito com uma árvore de segmentos
2D.
As respostas dos estados \([u']\) são inseridas (removidas) da
estrutura quando o vértice é inserido em (removido de) \(S\).
O máximo das respostas
dos vértices a sudoeste de \(u\)
é dado pela consulta pelo retângulo
\([-400,-400,x[u]-1, y[u]-1]\).
</p>

<p>
Embora a Quad-tree também possa ser utilizada, sua constante é consideravelmente
maior que a árvore de segmentos,
o que pode ocasionar em TLE, dependendo da
implementação.
</p>

<ul class="org-ul">
<li>Complexidade: \(O(N\log^2(800)) = O(N)\) considerando uma constante.</li>
</ul>
</div>
</div>

<div id="outline-container-orgb858c86" class="outline-2">
<h2 id="orgb858c86"><span class="section-number-2">8</span> URI 1753 Knights Of The Round Table</h2>
<div class="outline-text-2" id="text-8">
<p>
Este foi o Problema K da Nacional de 2014. Veja a discussão
sobre ele <a href="http://codeforces.com/blog/entry/14650">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-orgc024212" class="outline-2">
<h2 id="orgc024212"><span class="section-number-2">9</span> URI 1491 Blogger Language</h2>
<div class="outline-text-2" id="text-9">
<p>
Este foi o Problema B da Nacional de 2013. Veja comentários
sobre ele
<a href="https://chococontest.wordpress.com/2013/11/15/solucionario-regional-south-america-2013/">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-org80fdf9f" class="outline-2">
<h2 id="org80fdf9f"><span class="section-number-2">10</span> URI 1427 The Scrooge Co Problem</h2>
<div class="outline-text-2" id="text-10">
<p>
O problema em questão é o clássico
Weighted SSSP (Single-Source Shortest
Path), pedindo para imprimir também o caminho, não só o custo do
caminho mínimo.
Se resolver com Dijkstra, passa tranquilamente. No entanto,
observe que o grafo é pequeno (menos de 100 vértices) e que são também
poucos casos de teste (menos de 100). Assim, até Floyd-Warshall deve
passar, e o código do Floyd-Warshall é mais simples e mais curto (4
linhas!) que o código do Dijkstra, sendo bem tranquilo também
recuperar o caminho com o Floyd-Warshall.
</p>

<ul class="org-ul">
<li>Complexidade: \(O(N^3)\)</li>
</ul>
</div>
</div>

<div id="outline-container-orgdd9a4d1" class="outline-2">
<h2 id="orgdd9a4d1"><span class="section-number-2">11</span> URI 1915 Help Chaves</h2>
<div class="outline-text-2" id="text-11">
<p>
Crie um grafo bipartido \((A\cup B,E)\) em que \(A\) seja o conjunto dos
\(N\) amigos e \(B\) o conjunto dos \(M\) brinquedos. Para cada par
\((a,b)\in A\times B\), calcule (via PD) a "distância de edição"
de \(a\)
para \(b\). Se essa distância for um número múltiplo de 5, crie a
aresta; senão, não. Depois de o grafo estar montado, é só rodar seu
algoritmo preferido de emparelhamentos máximos em grafos bipartidos
(até FFEK serve!).
</p>

<ul class="org-ul">
<li>Complexidade: \(O(100^2NM)\) para montar o grafo (o \(100^2\) é o custo
de cada PD, já que as palavras têm no máximo 100 caracteres)
\(+\) \(O(NM)\) para o FFEK. Não fique com medo de \(100^2NM\) ser
\(\approx 10^8\) no pior caso de \(N\) e de \(M\) ;)</li>
</ul>
</div>
</div>

<div id="outline-container-org58cf566" class="outline-2">
<h2 id="org58cf566"><span class="section-number-2">12</span> UVA 13018 Dice Cup</h2>
<div class="outline-text-2" id="text-12">
<p>
Problema muito fácil. Perceba que os valores de \(N\) e de \(M\) são
pequenos. Então, testar todas as possibilidades de soma entre os
inteiros e ver quais são as que mais ocorrem é totalmente factível.
</p>

<p>
Se você ainda é iniciante e tem dificuldade em implementar esta
solução, vou dar um pouco mais de detalhes: Crie um vetor \(V\)
de inteiros com
pelo menos 40 posições, já que 40 é o
valor máximo  possível para uma soma de dois d20. Em cada caso de
teste, zere esse vetor. Então, comece um for sobre uma variável \(i\) de
1 até \(N\) e aninhe dentro desse for um for sobre uma variável \(j\) de 1
até \(M\), incrementando \(V[i+j]\) a cada iteração. No final, basta
varrer todo o vetor \(V\) para identificar qual valor ocorre mais vezes
(ou seja, qual índice \(i\) tem \(V[i]\) máximo)
e varrer uma segunda vez para imprimir todos os valores que ocorrem
esse número máximo de vezes.
</p>

<p>
Para imprimir uma linha de branco entre casos de teste consecutivos,
você pode utilizar uma flag <code>first</code> (que começa valendo 1)
e, antes de dar a saída para um caso
de teste, fazer:
</p>

<div class="org-src-container">
<pre><code class="src src-cpp"><span style="color: #00bfff;">if</span> (first) first = 0;
<span style="color: #00bfff;">else</span> printf(<span style="color: #deb887;">"\n"</span>);
</code></pre>
</div>

<ul class="org-ul">
<li>Complexidade: \(O(NM)\).</li>
</ul>
</div>
</div>

<div id="outline-container-org08c88b2" class="outline-2">
<h2 id="org08c88b2"><span class="section-number-2">13</span> UVA 13025 Back to the Past</h2>
<div class="outline-text-2" id="text-13">
<p>
Dispensa comentários :P
</p>
</div>
</div>

<div id="outline-container-org4ccf7ab" class="outline-2">
<h2 id="org4ccf7ab"><span class="section-number-2">14</span> UVA 665 False Coins</h2>
<div class="outline-text-2" id="text-14">
<p>
Dicas podem ser encontradas na página 40 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-org250517b" class="outline-2">
<h2 id="org250517b"><span class="section-number-2">15</span> UVA 12005 Bubble Sort</h2>
<div class="outline-text-2" id="text-15">
<p>
Assumamos sem perda de generalidade que estamos trabalhando com uma
permutação \(\pi\) de \(\{1,\dotsc,n\}\) tomada sob distribuição
uniforme (o problema garante que você pode assumir que os inteiros no
array são todos distintos, o que facilita).
Seja \(X\) a <a href="https://en.wikipedia.org/wiki/Random_variable">variável aleatória</a> que assume o número de inversões numa
dada permutação \(\pi\), i.e. o número de pares \((i,j)\) tais que
\(i < j\)
e \(\pi(i) > \pi(j)\). É óbvio que o que o problema pede, o número
esperado de trocas do <a href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a> para ordenar \(\pi\), é
\(\mathbb E(X)\), i.e. o <a href="https://en.wikipedia.org/wiki/Expected_value">valor esperado</a> de \(X\). Sendo
\(Y_{ij}\) a variável aleatória que assume o valor 1 se o par \((i,j)\) é
uma inversão, ou 0 caso contrário, temos obviamente que
</p>

\begin{equation*}
\mathbb E(X) = \mathbb E\biggl(\sum_{i}\sum_{j>i} Y_{ij}\biggr).
\end{equation*}

<p>
Da <a href="https://en.wikipedia.org/wiki/Expected_value#Linearity">linearidade da esperança</a>:
</p>

\begin{equation*}
\mathbb E(X) = \sum_{i}\sum_{j>i} \mathbb E(Y_{ij}).
\end{equation*}

<p>
Deixo como exercício você continuar as contas e fechar uma fórmula
\(O(1)\) em função de \(n\) para \(\mathbb E(X)\).
</p>

<ul class="org-ul">
<li>Complexidade: \(O(1)\) para o cálculo de \(E(X)\) (denominador e
numerador) \(+\) \(O(\log n)\) para o
Algoritmo de Euclides (para simplificar a fração).</li>
</ul>
</div>
</div>

<div id="outline-container-org2c68688" class="outline-2">
<h2 id="org2c68688"><span class="section-number-2">16</span> UVA 11048 Automatic Correction of Misspellings</h2>
<div class="outline-text-2" id="text-16">
<p>
Calouros, vocês têm totais condições para fazer este problema!
Este problema não requer nenhum conhecimento especial para ser
resolvido. Os mais experientes talvez tentariam aplicar a PD da
distância de edição aqui, mas definitivamente não é necessário.
</p>

<p>
Note que tanto o número de palavras no dicionário quanto o número de
consultas é pequeno neste problema, assim como o tamanho das palavras
envolvidas na brincadeira. Então, não precisam ser tão preciosistas
em relação à complexidade da solução. A solução que eu apresento a
seguir é a mais simples possível. Soluções mais eficientes existem,
mas esta aqui já passa (e tranquilamente!).
</p>

<p>
Para cada <i>query</i> \(s\), simplesmente itere sobre todas as palavras \(w\) do
dicionário. Se \(s=w\) (pode usar a <code>strcmp()</code> da <code>string.h</code>),
aborte o laço (\(s\) is correct). Se você
conseguiu identificar que \(s\) é <i>misspelling</i> de \(w\) (já vou explicar
como fazer isso), memorize isso, mas não aborte o laço (pois pode ser
que \(s\) seja igual a um outro \(w\) mais pra frente).
</p>

<p>
Implementar a função que verifica se uma palavra \(s_1\) é uma
<i>misspelling</i> de uma palavra \(s_2\) pode ser um pouco complicado para
iniciantes. É bem possível que você até consiga fazer o serviço, mas
que seu código fique bem complicado. Nestas horas, pensar em recursão
pode ajudar. A seguir apresento a minha função, que recebe duas
strings \(s_1\)
e \(s_2\), de tamanhos respectivamente \(t_1\) e \(t_2\),
e verifica se a string definida a partir da
posição \(i\) de \(s_1\) é uma <i>misspelling</i> da string definida a partir da
posição \(j\) de \(s_2\). Na hora de chamar, é só fazer:
</p>

<div class="org-src-container">
<pre><code class="src src-cpp"><span style="color: #00bfff;">if</span> (misspelling(str, 0, strlen(str), word[i], 0, strlen(word[i]) <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">...</span>
</code></pre>
</div>

<p>
Por favor, tente você desenvolver sua própria função. Olhe meu código
só quando você já conseguir ter feito o seu, para ver como você
poderia ter feito diferente. Tente também desenvolver um código
iterativo (que no fim das contas não vai ser muito diferente do
recursivo).
</p>

<div class="org-src-container">
<pre><code class="src src-cpp"><span style="color: #98f5ff;">int</span> <span style="color: #daa520;">misspelling</span>(<span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">s1</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">i</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">t1</span>, <span style="color: #98f5ff;">char</span> *<span style="color: #4eee94;">s2</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">j</span>, <span style="color: #98f5ff;">int</span> <span style="color: #4eee94;">t2</span>) {
  <span style="color: #00bfff;">if</span> (i == t1) <span style="color: #00bfff;">return</span> j == t2 - 1;
  <span style="color: #00bfff;">if</span> (j == t2) <span style="color: #00bfff;">return</span> i == t1 - 1;
  <span style="color: #00bfff;">return</span> !strcmp(s1 + i + 1, s2 + j) || !strcmp(s1 + i, s2 + j + 1) ||
    (s1[i] != s2[j] &amp;&amp; !strcmp(s1 + i + 1, s2 + j + 1)) ||
    (s1[i] != s2[j] &amp;&amp; s1[i] == s2[j + 1] &amp;&amp; s1[i + 1] == s2[j] &amp;&amp;
     !strcmp(s1 + i + 2, s2 + j + 2)) || <span style="color: #7f7f7f;">// </span><span style="color: #7f7f7f;">sem perigo de seg fault :)</span>
    (s1[i] == s2[j] &amp;&amp; misspelling(s1, i + 1, t1, s2, j + 1, t2));
}
</code></pre>
</div>

<ul class="org-ul">
<li>Complexidade: \(O(nm\times 25^2)\); o \(25^2\) se deve ao custo
\(O(t_1t_2)\) da minha função <code>misspelling()</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgde115a2" class="outline-2">
<h2 id="orgde115a2"><span class="section-number-2">17</span> UVA 10739 String to Palindrome</h2>
<div class="outline-text-2" id="text-17">
<p>
Este problema é muito fácil se você já conhece PD e
<a href="https://en.wikipedia.org/wiki/Levenshtein_distance">distância de edição</a> (e o clássico algoritmo de
<a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Needleman-Wunsch</a>).
Basta lembrar que um palíndromo é uma palavra
igual ao seu reverso. Então, é evidente que
a distância de edição de uma
palavra até seu reverso seja o dobro da menor distância de edição
desta palavra para algum palíndromo.
</p>

<ul class="org-ul">
<li>Complexidade: \(O(1000^2)\), já que 1000 é o comprimento máximo de uma
palavra da entrada.</li>
</ul>
</div>
</div>

<div id="outline-container-org183780b" class="outline-2">
<h2 id="org183780b"><span class="section-number-2">18</span> UVA 10192 Vacation</h2>
<div class="outline-text-2" id="text-18">
<p>
Leia a Seção 6.5.2 (Longest Common Subsequence, LCS &#x2014; não confundir com
Longest Common Substring, que também é abreviado LCS) do livro dos
Halim, que reduz o problema ao problema de <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">distância de edição</a> (e,
portanto, que pode ser resolvido com o clássico algoritmo de
<a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Needleman-Wunsch</a>).
</p>
</div>
</div>

<div id="outline-container-org50d80f2" class="outline-2">
<h2 id="org50d80f2"><span class="section-number-2">19</span> UVA 11258 String Partition</h2>
<div class="outline-text-2" id="text-19">
<p>
Se você nunca estudou PD, estude (comece pelas seções respectivas nos
livros do Cormen, do Skiena e dos Halim). Após estudar, com certeza
você vai conseguir resolver este problema com PD sem maiores
dificuldades. Dica: perceba que tudo gira em torno das escolhas entre
particionar o número a partir de uma posição e não particionar ;)
</p>

<ul class="org-ul">
<li>Complexidade: \(O(m^2)\) para cada caso de teste, sendo \(m\) o número de
dígitos do inteiro fornecido naquele caso de teste.</li>
</ul>
</div>
</div>

<div id="outline-container-org600fcf7" class="outline-2">
<h2 id="org600fcf7"><span class="section-number-2">20</span> UVA 10891 Game of Sum</h2>
<div class="outline-text-2" id="text-20">
<blockquote>
<p>
<i>Dicas escritas por Alesom Zorzi.</i>
</p>
</blockquote>

<p>
É bem claro que é uma PD, o próprio exemplo explica isso. Tentei fazer
alternando os turnos, mas na realidade da para perceber que não importa
em qual turno estamos, já que ambos os jogadores querem tomar o máximo
possível. A diferença é que \(S[i][j]\) guarda o valor apenas do Player
1 já
que o esse valor é possível facilmente obter o valor do player 2 para
fazer a subtração. Um esboço da PD:
</p>

<div class="org-src-container">
<pre><code class="src src-cpp">pd(x, y)
  <span style="color: #00bfff;">if</span> (x==y) <span style="color: #00bfff;">return</span> valor[x];
  <span style="color: #00bfff;">for</span> (i =x; i &lt; y;i++)
    resp = max(resp, <span style="color: #98f5ff;">tomar</span> <span style="color: #4eee94;">i</span> - x + 1 elementos da esquerda para a direita);
  <span style="color: #00bfff;">for</span> (i = y; i &gt; x;i--)
    resp = max(resp, <span style="color: #98f5ff;">tomar</span> <span style="color: #4eee94;">y</span> - i +1 elementos da direita para a esquerda);
  resp = max(resp, <span style="color: #98f5ff;">tomar</span> todos os elementos de x <span style="color: #98f5ff;">at&#233;</span> <span style="color: #4eee94;">y</span>);
  <span style="color: #00bfff;">return</span> S[i][j] = resp;
</code></pre>
</div>

<ul class="org-ul">
<li>Complexidade: \(O(N^3)\), já que são \(N^2/2\) estados e a computação de
cada estado requer tempo \(O(N)\).</li>
</ul>
</div>
</div>

<div id="outline-container-orgddc0526" class="outline-2">
<h2 id="orgddc0526"><span class="section-number-2">21</span> UVA 11610 Reverse Prime</h2>
<div class="outline-text-2" id="text-21">
<blockquote>
<p>
<i>Dicas escritas por Matheus Dall Rosa.</i>
</p>
</blockquote>

<p>
  Primeiro calculamos todos os primos até \(10^6\) com o crivo de
  Eratóstenes, e então para computar os primos
reversos podemos verificar se o reverso de cada inteiro no intervalo
\([10^6,10^7]\) é um número primo menor que
\(10^6\).
</p>

<p>
Para respondermos a operação <i>query</i> podemos utilizar uma BIT e para
calcular a soma acumulada dos fatores
primos de todos os primos reversos em \(O(\log(N))\)
onde \(N\) é a quantidade de primos reversos.
</p>

<p>
Para processarmos a operação <i>deletion</i> devemos remover o número de
fatores primos deste primo reverso da
BIT.
</p>

<p>
Também devemos removê-lo da lista de primos reversos, podemos fazer
está operação em \(O(N)\), visto que o
número de operações do tipo <i>deletion</i> é no máximo 3500 e como o número de
primos reversos no intervalo dado é
aproximadamente 79000 então temos: \(3500*79000 = 276500000\), um algoritmo
com esta complexidade provavelmente não passaria se o problema
tivesse multiplos casos de teste porém o problema em questão só
possui um caso de teste.
</p>

<ul class="org-ul">
<li>Complexidade: Assim teremos \(O(Q*log(N))\) para responder as
operações do tipo <i>query</i> e \(O(D*N)\) para responder todas as
operações do tipo <i>deletion</i>.</li>
</ul>
</div>
</div>

<div id="outline-container-org7400792" class="outline-2">
<h2 id="org7400792"><span class="section-number-2">22</span> URI 1634 Another Lottery</h2>
<div class="outline-text-2" id="text-22">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
A chave do problema é perceber que, devido ao prêmio dobrar a cada
round, o prêmio no último round vai ser maior do que a soma de todos os
anteriores. Portanto, o proplema se resume a encontrar a probabilidade
de cada apostador vencer o último round, que é dada pela quantidade de
bilhetes comprado pelo apostador no último round, dividido pelo total de
bilhetes vendidos no último round. (Lembrando que a resposta precisa ser
uma fração simplificada).
</p>

<ul class="org-ul">
<li>Complexidade: \(O(n)\)</li>
</ul>
</div>
</div>

<div id="outline-container-orgf1c9bbd" class="outline-2">
<h2 id="orgf1c9bbd"><span class="section-number-2">23</span> URI 2014 Blood Groups</h2>
<div class="outline-text-2" id="text-23">
<blockquote>
<p>
<i>Dicas escritas por Alesom Zorzi.</i>
</p>
</blockquote>

<p>
Este problema é bem confuso, demorei mesmo para entender o que ele
pedia. Mas depois de ler algumas vezes e montar os casos com muuuita
calma, percebi que ele quer apenas verificar se existe um emparelhamento
perfeito em um grafo-bipartido (vide
<a href="http://moreno.cin.ufpe.br/~if775/2013.1/ppt/Emparelhamento%20emGrafosBipartidos.pdf">aqui</a>). Para o emparelhamento máximo no grafo bipartido, eu usei o
algoritmo de Hopcroft-Karp que é um algoritmo mais eficiente para
encontrar o emparelhamento máximo em grafos bipartidos (quando comparado
aos métodos mais simples). Mas como ônus é mais complicado também, o
algoritmo pode ser encontrado
<a href="http://moreno.cin.ufpe.br/~if775/2013.1/ppt/Emparelhamento%20emGrafosBipartidos.pdf">aqui</a> e na Seção 9.10 do livro dos Halim.
</p>

<p>
Forme o grafo \(G\), com \(V(G) = A\cup B\) da seguinte forma:
A partição \(A\) do grafo terá \(N\)
 vértices e cada vértice será um dos pais;
A partição \(B\) também terá \(N\)
 vértices, mas estes vértices serão os \(N\)
 alelos do possível tipo sanguíneo.
</p>

<p>
Vai ter aresta \(uv\) com \(u \in A\) e \(v \in B\) se \(u\) pode doar o alelo
\(v\).
</p>

<p>
Depois é só verificar o emparelhamento máximo no grafo \(G\)
 e ver se o tamanho desse emparelhamento é igual a \(N\).
</p>

<ul class="org-ul">
<li>Complexidade: A complexidade do algoritmo fica:
\(O(Q*(N^2+|E|\sqrt{|V|}))=O(Q*N^2\sqrt N)\), já que \(|V|=O(N)\) e
\(|E|=O(N^2)\).</li>
</ul>
</div>
</div>

<div id="outline-container-org9e57a43" class="outline-2">
<h2 id="org9e57a43"><span class="section-number-2">24</span> URI 1671 Code</h2>
<div class="outline-text-2" id="text-24">
<p>
Sendo \(G\) o grafo definido no próprio enunciado do problema, perceba que
qualquer <a href="https://en.wikipedia.org/wiki/Eulerian_trail">trilha euleriana</a> em \(G\) define exatamente o que o problema pede
como resposta. Para computar uma trilha euleriana num grafo, existem
vários algoritmos, sendo o mais eficiente o Algoritmo de Hierholzer, que
pode ser implementado com listas duplamente encadeadas em tempo linear
no tamanho do grafo.
 O livro dos Halim (3<sup>a</sup> edição)
 apresenta no início da página 180
 uma implementação quadrática no tamanho do grafo
para o Algoritmo de Hierholzer.
Neste problema em particular, você não precisa construir o grafo
explicitamente, e implementar o Algoritmo de Hierholzer pode ficar até
mais fácil assim.
</p>

<ul class="org-ul">
<li>Complexidade: utilizando uma implementação linear para o Algoritmo de
Hierholzer:
\(O(\lvert V\rvert+\lvert E\rvert) = O(10^{n-1}+10\times
  10^{n-1})=O(10^n)\), o que é factível, já que \(n\leq 6\); utilizando
um <code>set</code> para lembrar quais arestas já foram visitadas:
\(O((\lvert V\rvert+\lvert E\rvert)\log\lvert E\rvert) = O(n\times
  10^n)\).</li>
</ul>
</div>
</div>

<div id="outline-container-org69a9ea6" class="outline-2">
<h2 id="org69a9ea6"><span class="section-number-2">25</span> URI 1748 Fence the Vegetables</h2>
<div class="outline-text-2" id="text-25">
<p>
Este foi o Problema F da Nacional de 2014. Veja a discussão
sobre ele <a href="http://codeforces.com/blog/entry/14650">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-orge81f37b" class="outline-2">
<h2 id="orge81f37b"><span class="section-number-2">26</span> URI 2007 Fence the Vegetables Fail</h2>
<div class="outline-text-2" id="text-26">
<blockquote>
<p>
<i>Dicas escritas por Alesom Zorzi.</i>
</p>
</blockquote>

<p>
Esse problema é difícil, de 0 a 10 eu daria um 8. Tem muitos truques
de implementação que é difícil se ater na hora da competição. Apesar
do problema parecer de Geometria (verificar se um ponto esta dentro de
um polígono, não necessariamente convexo) os limites de entrada são
realmente muito grandes \(10^5\) vértices e \(10^5\) pontos. Então é
necessário pensar em outra abordagem: O que facilita é o fato de todas
as arestas serem paralelas aos eixos. Assim podemos usar uma técnica
de Line Sweep (vide <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/">aqui</a> e <a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm">aqui</a>).
</p>

<p>
Assim, a abordagem que eu usei foi:
Primeiro, podemos notar que basta olhar para as arestas do polígono que
são paralelas ao eixo \(x\). Armazene então todas as arestas paralelas ao
eixo dos \(x\) (note que isso implica que todos os vértices do polígono
serão armazenados).
</p>

<p>
Agora passe uma "linha" por todos os pontos (incluindo os vértices do
polígono) em ordem de \(x\). Então teremos três casos: A linha encosta
em um
vértice que é inicio de uma aresta; A linha encosta em um vértice que é
final de uma aresta; A linha encosta em um ponto \(p\).
Se o primeiro caso
acontecer, devemos adicionar a aresta em um conjunto de arestas \(S\) que
estão ativas. Se o segundo caso acontecer devemos remover a aresta de
\(S\). Se o terceiro caso acontecer devemos verificar entre quais arestas
está o ponto \(p\) e contar ou não esse ponto para a resposta. Mas a
realidade é que apenas precisamos saber quantas arestas ativas existem
antes (ou depois) do ponto. Se existe um número par de arestas antes
dele quer dizer que ele está fora do polígono, se não esta dentro do
polígono.
</p>

<p>
Note que precisamos realizar as atualizações, remoções e consultas de
forma bastante eficaz (não pode ser linear, já estamos usando tempo
linear para o line sweep, ficaria \(10^5 * 10^5 + 10 ^5 / 2\) no pior
dos casos), então vamos recorrer a boa e velha BIT (ou Fenwick tree)
(vide <a href="https://en.wikipedia.org/wiki/Fenwick_tree">aqui</a> e <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/">aqui</a>). Assim, a cada vez que inserirmos alguma aresta a
no conjunto \(S\) iremos dar um update na BIT no lugar onde esta o valor
que representa a aresta \(a\) em \(S\). Para pesquisar, apenas verificamos
quantas arestas existem antes do ponto p com uma quer y na BIT.
</p>

<p>
Lindo né? Não. Já que os valores de \(x\) e \(y\) podem ir de \(-10^9\) até
\(10^9\). Mas como o número de pontos e vértices somados tem no máximo
tamanho de \(2*10^5\) podemos usar uma "compactação" para o \(y\) de todos
os elementos (vértices e pontos). Apenas ordene por ordem de \(y\) as
arestas e os pontos. Percorra o vetor e dê valores de 1 até \(N\), sendo
\(N\)
o número total de elementos no vetor. Agora sim podemos usar a BIT
para fazer as atualizações e consultas.
</p>

<ul class="org-ul">
<li>Complexidade \(N\log(N) = 10^5*log(10^5)\).</li>
</ul>
</div>
</div>

<div id="outline-container-orge1ecebf" class="outline-2">
<h2 id="orge1ecebf"><span class="section-number-2">27</span> URI 2012 Height Map</h2>
<div class="outline-text-2" id="text-27">
<p>
Este foi o Problema H da Nacional de 2015. Veja a discussão
sobre ele <a href="https://chococontest.wordpress.com/2015/11/23/solucionario-regional-south-america-2015/">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-orgfd860a9" class="outline-2">
<h2 id="orgfd860a9"><span class="section-number-2">28</span> URI 1752 Journey Through The Kingdom</h2>
<div class="outline-text-2" id="text-28">
<p>
Este foi o Problema J da Nacional de 2014. Veja a discussão
sobre ele <a href="http://codeforces.com/blog/entry/14650">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-org47a9dcb" class="outline-2">
<h2 id="org47a9dcb"><span class="section-number-2">29</span> URI 2009 Just a bit sorted</h2>
<div class="outline-text-2" id="text-29">
<p>
Este foi o Problema J da Nacional de 2015. Veja a discussão
sobre ele <a href="https://chococontest.wordpress.com/2015/11/23/solucionario-regional-south-america-2015/">neste link</a>.
</p>
</div>
</div>

<div id="outline-container-org76e6bd2" class="outline-2">
<h2 id="org76e6bd2"><span class="section-number-2">30</span> URI 2030 Pit Stop</h2>
<div class="outline-text-2" id="text-30">
<p>
Problema <i>ad hoc</i> fácil ;)
</p>
</div>
</div>

<div id="outline-container-org93e6f58" class="outline-2">
<h2 id="org93e6f58"><span class="section-number-2">31</span> URI 2031 Rock, Paper, Airstrike</h2>
<div class="outline-text-2" id="text-31">
<p>
Problema <i>ad hoc</i> muito fácil ;)
</p>
</div>
</div>

<div id="outline-container-orgd4a4355" class="outline-2">
<h2 id="orgd4a4355"><span class="section-number-2">32</span> UVA 13049 Combination Lock</h2>
<div class="outline-text-2" id="text-32">
<blockquote>
<p>
<i>Dicas escritas por Kétly Machado.</i>
</p>
</blockquote>

<p>
Para solucionar este problema, basta olharmos para cada combinação
<code>Initial</code> e <code>Target</code> e computarmos a resposta da seguinte forma:
</p>

<div class="org-src-container">
<pre><code class="src src-cpp">resposta = 0
Para todo i de 0 at&#233; n fa&#231;a
  resposta = resposta + min(n&#250;mero de movimentos para se <span style="color: #98f5ff;">alcan&#231;ar</span> <span style="color: #4eee94;">Target</span>[i] a partir de Inicial[i] girando no sentido hor&#225;rio,
                            n&#250;mero de movimentos para se <span style="color: #98f5ff;">alcan&#231;ar</span> <span style="color: #4eee94;">Target</span>[i] a partir de Inicial[i] girando no sentido anti-hor&#225;rio)
</code></pre>
</div>

<ul class="org-ul">
<li>Complexidade: \(O(n)\)</li>
</ul>
</div>
</div>

<div id="outline-container-org6e9c299" class="outline-2">
<h2 id="org6e9c299"><span class="section-number-2">33</span> UVA 11094 Continents</h2>
<div class="outline-text-2" id="text-33">
<p>
Dicas podem ser encontradas na página 137 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-org2c7fddb" class="outline-2">
<h2 id="org2c7fddb"><span class="section-number-2">34</span> UVA 11357 Ensuring Truth</h2>
<div class="outline-text-2" id="text-34">
<blockquote>
<p>
<i>Dicas escritas por Alesom Zorzi.</i>
</p>
</blockquote>

<p>
  Este é um problema simples, dado uma expressão booleana na <a href="https://en.wikipedia.org/wiki/Disjunctive_normal_form">DNF</a>, você
precisa dizer se existe um conjunto de valores binários
 \(v_1, v_2, \dotsc,v_n\)
 que, quando aplicado às variáveis $va<sub>1</sub>, va<sub>2</sub>, \dotsc, va<sub>n</sub> $ da
expressão booleana que é dada na entrada, faz com que tal expressão
tenha como valor final Verdadeiro (ou 1, ou true, entenda como quiser),
ou seja, dizer se a expressão é satisfatível.
</p>

<p>
Como a forma normal é na DNF, sabemos que apenas uma das cláusulas
precisa ser verdadeira, e para uma clausula ser verdadeira é necessário
que todos as suas variáveis tenham valores positivos, ou seja, a
variável  \(va_1\) precisa receber um valor 1 (ou verdadeiro), já a
variável \({\sim}va_1\) precisa receber um valor 0 (ou falso). Ou seja, é um
problema guloso (<i>greedy</i>), o que significa que podemos sempre
escolher o melhor
localmente e isto conduzirá à melhor escolha do todo.
</p>

<p>
Então, o que precisamos fazer é testar para toda cláusula se
é possível
atribuir valores às variáveis de forma que não haja conflitos entre a
valoração das variáveis. Se em uma cláusula isso é possível, então, a
resposta é <code>YES</code>. Se em nenhuma das clausulas isso é possível, então, a
resposta é <code>NO</code>.
</p>

<ul class="org-ul">
<li>Complexidade: \(O(n)\), sendo \(n\) o número de caracteres lidos na entrada.</li>
</ul>

<p>
P.S.: Uma dica para a leitura da entrada é: Guarde as cláusulas
separadas, em vetores de pares por exemplo, onde o par é
<code>variável/valorNecessário</code>. <code>valorNecessário</code> é 1 se a variável
 não tiver um
sinal de \(\sim\)
 no caractere anterior e 0 se tiver. Quando ler um '<code>(</code>', inicie
um novo vetor de pares <code>variável/valorNecessário</code> e só termine o vetor
quando ler um '<code>)</code>'. Deste modo fica mais fácil de verificar se existe
conflito entre duas variáveis na mesma clausula.
</p>
</div>
</div>

<div id="outline-container-org847d02c" class="outline-2">
<h2 id="org847d02c"><span class="section-number-2">35</span> UVA 11475 Extend to Palindromes</h2>
<div class="outline-text-2" id="text-35">
<blockquote>
<p>
<i>Dicas escritas por Kétly Machado.</i>
</p>
</blockquote>

<p>
Seja \(S\) a string original dada na entrada, indexada de \(0\) até
\(tam(S) - 1\), para solucionar este problema precisamos encontrar a maior
substring \(S'\) de \(S\) que contenha \(S[tam(S) - 1]\) e seja um
palíndromo. Encontrada \(S'\), dada pelos caracteres \(S[i]\) até
\(S[tam(S) - 1]\), a resposta é dada pela concatenação de \(S\) com a
substring \(S''\) invertida, sendo \(S''\) dada pelos caracteres \(S[0]\) até
\(S[i - 1]\) (se \(i - 1 < 0\), então \(S''\) é uma string vazia).
</p>

<p>
Para encontrar \(S'\) é possível utilizar uma busca linear na string \(S\),
testando para cada \(S[i] = S[tam(S) - 1]\) se a substring dada pelos
caracteres \(S[i]\) até \(S[tam - 1]\) forma um palíndromo.
</p>

<ul class="org-ul">
<li>Complexidade: Embora acredite que esta solução no pior caso tenha
complexidade \(O(n * (n + 1) / 2) = O(n^2)\) e, teoricamente não passe,
já que \(n <= 10^5\), a mesma foi suficiente para atender às entradas do
UVA.</li>
</ul>
</div>
</div>

<div id="outline-container-org9d73e04" class="outline-2">
<h2 id="org9d73e04"><span class="section-number-2">36</span> UVA 622 Grammar Evaluation</h2>
<div class="outline-text-2" id="text-36">
<p>
Dicas podem ser encontradas na página 239 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-org7bfae97" class="outline-2">
<h2 id="org7bfae97"><span class="section-number-2">37</span> UVA 10859 Placing Lampposts</h2>
<div class="outline-text-2" id="text-37">
<p>
Tente se inspirar na PD para o Problema de Cobertura Mínima por
Vértices (<i>MVC: Minimum Vertex Cover</i>) <span class="underline">em árvores</span>, muito bem
explicada nas páginas 175&#x2013;176 do livro dos Halim (3<sup>a</sup> edição).
</p>
</div>
</div>

<div id="outline-container-orgb5587c7" class="outline-2">
<h2 id="orgb5587c7"><span class="section-number-2">38</span> UVA 12542 Prime Substring</h2>
<div class="outline-text-2" id="text-38">
<p>
Dicas podem ser encontradas na página 203 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-orgcd2fb98" class="outline-2">
<h2 id="orgcd2fb98"><span class="section-number-2">39</span> UVA 13026 Search the Khoj</h2>
<div class="outline-text-2" id="text-39">
<blockquote>
<p>
<i>Dicas escritas por Kétly Machado.</i>
</p>
</blockquote>

<p>
Neste problema, para cada telefone presente na agenda do pai de Khoj, é
realizada a comparação com o telefone memorizado por Khoj, avaliando
para cada caractere \(a\) do \(i\)-ésimo telefone da agenda e cada caractere
\(k\) do telefone memorizado por Khoj se \(a = k\). Seja \(f\) o número de
vezes em que a comparação é falsa, se \(f \leq 1\) então o \(i\)-ésimo
telefone da agenda pode ser impresso na saída. Devemos realizar esse
procedimento para todo \(i\) de \(1\) até \(n\).
</p>

<ul class="org-ul">
<li>Complexidade: Seja \(t\) o tamanho padrão dos telefones da agenda e do
telefone memorizado por Khoj, temos uma complexidade de \(O(nt)\), como \(n
  \leq 10^3\) e \(t \leq 11\), temos uma complexidade da ordem de \(10^4\), que
passa tranquilamente.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdf002a9" class="outline-2">
<h2 id="orgdf002a9"><span class="section-number-2">40</span> UVA 11319 Stupid Sequence?</h2>
<div class="outline-text-2" id="text-40">
<p>
Dicas podem ser encontradas na página 348 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-org71afe5f" class="outline-2">
<h2 id="org71afe5f"><span class="section-number-2">41</span> UVA 488 Triangle Wave</h2>
<div class="outline-text-2" id="text-41">
<p>
Dicas podem ser encontradas na página 239 do livro dos Halim (3<sup>a</sup>
edição).
</p>
</div>
</div>

<div id="outline-container-orgeb4c262" class="outline-2">
<h2 id="orgeb4c262"><span class="section-number-2">42</span> LA 5057 Worst Location</h2>
<div class="outline-text-2" id="text-42">
<p>
Este foi o problema A da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org5dd742c" class="outline-2">
<h2 id="org5dd742c"><span class="section-number-2">43</span> LA 5058 Counting BST</h2>
<div class="outline-text-2" id="text-43">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
Problema bem legal de combinatória. Existem
\(\binom M N =\frac{M!}{(M-N)!N!}\)
subconjuntos de valores que podem ser
escolhidos. Suponha que tenhamos escolhidos um deles, então precisamos,
para cada nó da árvore, recuperar a quantidade de valores na sub-árvore
esquerda e na subárvore direita e encontrar de quantas formas podemos
organizar estes valores, de forma que a ordem dos valores da subárvore
esquerda e direita seja preservada. Podemos fazer isto recursivamente e
com a ajuda de uma programação dinâmica. Ao final, basta multiplicar
este valor por \(\binom M N\) e temos a resposta.
</p>

<ul class="org-ul">
<li>Complexidade: A complexidade de calcular a quantidade de ordens
possíveis, dados a
quantidade de valores na esquerda e na direita pode ser feita em
\(O(N)\), levando em conta todos os casos de teste. A contagem para cada
nó é constante para cada nó. O cálculo das combinações
pode ser feito em tempo constante se os
fatoriais e seus inversos multiplicativos forem calculados antes dos
casos de teste.</li>
</ul>
</div>
</div>

<div id="outline-container-orga6cce4c" class="outline-2">
<h2 id="orga6cce4c"><span class="section-number-2">44</span> LA 5059 Playing With Stones</h2>
<div class="outline-text-2" id="text-44">
<p>
Este foi o problema C da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org568f31b" class="outline-2">
<h2 id="org568f31b"><span class="section-number-2">45</span> LA 5060 Arm Wrestling Tournament</h2>
<div class="outline-text-2" id="text-45">
<p>
Este foi o problema D da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org6b8f597" class="outline-2">
<h2 id="org6b8f597"><span class="section-number-2">46</span> LA 5061 Lightning Energy Report</h2>
<div class="outline-text-2" id="text-46">
<p>
Este foi o problema E da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org73c2e10" class="outline-2">
<h2 id="org73c2e10"><span class="section-number-2">47</span> LA 5062 Transitive Closure</h2>
<div class="outline-text-2" id="text-47">
<p>
Este foi o problema F da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org71ef16d" class="outline-2">
<h2 id="org71ef16d"><span class="section-number-2">48</span> LA 5063 Just Sum It</h2>
<div class="outline-text-2" id="text-48">
<p>
Este foi o problema G da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-orgea9151f" class="outline-2">
<h2 id="orgea9151f"><span class="section-number-2">49</span> LA 5064 Serial Numbers</h2>
<div class="outline-text-2" id="text-49">
<p>
Este foi o problema H da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org8906335" class="outline-2">
<h2 id="org8906335"><span class="section-number-2">50</span> LA 5065 Romantic Date</h2>
<div class="outline-text-2" id="text-50">
<p>
Este foi o problema I da Regional de Jakarta 2010. Dicas podem ser
encontradas <a href="http://www.suhendry.net/blog/?p=1389">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-org789e22d" class="outline-2">
<h2 id="org789e22d"><span class="section-number-2">51</span> LA 5066 Fire Drill</h2>
<div class="outline-text-2" id="text-51">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
Este problema pode ser resolvido com uma combinação de uma busca em
largura (BFS) para calcular a distância das células até a saída e de
uma programação dinâmica para decidir quais voluntários
escolher. Quando um voluntário for escolhido é preciso ir até ele e
carregá-lo de volta, portanto, custo de escolher um voluntário é 3
vezes a distância dele até a saída.
</p>

<ul class="org-ul">
<li>Complexidade: A busca possui complexidade linear, enquanto a PD é
\(O(NS)\).</li>
</ul>
</div>
</div>

<div id="outline-container-orgd6aafee" class="outline-2">
<h2 id="orgd6aafee"><span class="section-number-2">52</span> URI 1912 Help Seu Madruga</h2>
<div class="outline-text-2" id="text-52">
<blockquote>
<p>
<i>Dicas escritas por João Winckler.</i>
</p>
</blockquote>

<p>
Queremos encontrar a altura onde Seu Madruga deve fazer o corte, para
tal usamos uma busca binária. A altura do corte, se for possível, vai
estar entre 0 e a altura máxima dos papéis. Quando fazemos busca
binária em um valor double, ao invés de compararmos se o inicio é menor
ou igual ao fim para abortarmos a busca, repetimos o algoritmo X vezes, que
sabemos que será o suficiente para conseguirmos a resposta correta. Ao
fim da busca, checamos se a área formada pelo corte é igual a
área desejada com o erro de precisão de 4 casas decimais. Para fazer isso,
subtraímos a área obtida com o corte da área desejada, se o valor
absoluto do resultado for menor a 10<sup>-4</sup>, a resposta está
correta. Caso contrário, é impossível fazer um corte que resulte na
área desejada.
</p>

<ul class="org-ul">
<li>Complexidade: A busca binária tem complexidade \(O(\log N)\), mas para
cada busca devemos passar por todos os papéis para descobrir qual é a área
formada pelo corte, resultando na complexidade \(O(N\log N)\).</li>
</ul>
</div>
</div>

<div id="outline-container-org8525a8d" class="outline-2">
<h2 id="org8525a8d"><span class="section-number-2">53</span> URI 1856 Arya's Death List</h2>
<div class="outline-text-2" id="text-53">
<blockquote>
<p>
<i>Dicas escritas por Matheus Dall Rosa.</i>
</p>
</blockquote>

<p>
Este problema pode ser resolvido utilizando setorização por raiz
quadrada. Esta técnica consiste na separação de um vetor de tamanho N
em aproximadamente \(\frac{N}{\sqrt{N}}\) setores de tamanho
\(\sqrt{N}\), assim podemos iterar sobre todos os setores em \(O(\sqrt{N})\),
cada setor pode ser representado por uma struct que possui o id da
primeira pessoa do setor, o id da última pessoa do setor e a
quantidade de pessoas pertencentes a este setor, o que vai ser útil
para podermos efetuar a respota da query de tipo Q.
</p>

<p>
Antes de começarmos a responder as operações devemos pré-processar o
vetor de pessoas da entrada, primeiramente mapearemos cada pessoa do
intervalo \(1..10^9\) para o intervalo \(1..5 \cdot 10^4\), o que pode ser feito
através de um map, cada id após ser mapeado deve ser inserido em uma
lista encadeada e o seu iterador deve ser armazenado em um vetor de
iteradores IDX[\(1..5 \cdot 10^4\)], o id de seu setor também deve ser salvo em
um vetor setID[\(1..5 \cdot 10^4\)].
</p>

<p>
Resposta da query do tipo R e:
Primeiramente buscamos o identificador de e no intervalo \(1..5 \cdot 10^4\)
chamaremos este identificador de ei, e então buscamos o iterador de ei
em IDX[ei] para fazermos a remoção da pessoa da lista encadeada e
então a remoção da pessoa do próprio map utilizado para o mapeamento,
devemos também diminuir a quantia de pessoas no intervalo ao qual ei
pertence e também resolvermos alguns casos de borda por ex: quando ei
é o primeiro ou último elemento do setor.Complexidade: \(O(1)\) para
retirarmos a pessoa da lista e \(O(\log{N})\) para retirarmos do map,
resultando em \(O(\log{N})\).
</p>

<p>
Resposta da query do tipo I p e:
Primeiramente buscamos o identificador de p e e no intervalo 1..5
&sdot; 10<sup>5</sup>
chamaremos estes de kp e ke respectivamente, acessamos o iterador de
ke na lista encadeada através de IDX[ke] e então inserimos kp a frente
de ke na lista, após isso devemos inserir kp no primeiro setor com id
maior ou igual ao setID[kp] que possui espaço livre, esta parte da
operação exige o controle sobre o tamanho do setor e também se
precisamos de um novo setor, após encontramos um setor livre devemos
incrementar sua quantidade. Complexidade: Por causa da procura por um
setor com espaço livre esta operação pode custar no pior caso
\(O(\sqrt{N})\), também devemos buscar os identificadores o que custa
\(O(\log{N})\), resultando em \(O(\sqrt{N} + \log{N})\).
</p>

<p>
Resposta da query do tipo Q a b:
Primeiramente buscamos o identificador de a e b no intervalo \(1..5
  \cdot 10^5\) chamaremos estes de ka e kb respectivamente, acessamos os
ids de seus setores em setID[ka] e setID[kb] fazemos a varredura de
todos os setores neste no intervarlo setID[ka]..setID[kb] fazendo a
contagem do total de pessoas. Complexidade: No pior caso essa
varredura pode custar O(sqrt(N)).
</p>

<ul class="org-ul">
<li>Complexidade: Com o processamento de todas as Q operações teremos uma
complexidade final de \(O(Q \cdot (\sqrt{N} + \log{N}))\).</li>
</ul>

<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
Solução alternativa: A princípio, eu pensei em resolver da seguinte
forma. Ler e armazenar toda a lista inicial e as consultas, sendo que
para cada comando de inserção, eu inseria o elemento em uma lista
encadeada (sempre mantendo o iterador de cada valor guardado, para não
precisar percorrer a lista toda). Para remoções e consultas de
intervalo, eu não fazia nada.
</p>

<p>
No final, todos os elementos que pudessem vir a aparecer no problema
estariam na lista, em uma ordem relativa com os que estariam ao mesmo
tempo. Então eu simplesmente itero sobre a lista, desde o início, e
guardo as posições de cada elemento na lista em um vetor <code>pos[]</code>,
iniciando em 1.
</p>

<p>
Percorrendo a lista inicial e as consultas novamente, para cada inserção
eu atulizo uma BIT da seguinte forma:
</p>

<ul class="org-ul">
<li>Inserção: <code>update(pos[p[i]], 1)</code></li>
<li>Remoção: <code>update(pos[e[i]], -1)</code></li>
<li>E para saber a posição de um elemento: <code>query(a[i])</code></li>
</ul>

<p>
Quando eu fizer a query, apenas os que estiverem antes de <code>a[i]</code>, naquele
suposto momento serão contados.
</p>

<p>
De início eu levei WA, até ver a solução do Matheus, em que ele havia
mapeado os valores para um intervalo menor. Eu fiz o mesmo, substituindo
cada novo valor a ser inserido por um outro valor, e levei Accept. Isso
foi preciso porque, pelo viso, um inimigo removido pode voltar para a
lista em algum momento, substituindo o valor que ele tinha em <code>pos[]</code>.
</p>

<p>
As leituras e as inserções na lista, podem ser feitas em tempo linear,
se for guardado o nó em que cada valor está.
</p>

<ul class="org-ul">
<li>Complexidade: Pra percorrer elas novamente atualizando a BIT:
\(O((N+Q)log(n))\)</li>
</ul>
</div>
</div>

<div id="outline-container-org6e8aebb" class="outline-2">
<h2 id="org6e8aebb"><span class="section-number-2">54</span> URI 1852 Stark Direwolves</h2>
<div class="outline-text-2" id="text-54">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
  Este problema é uma aplicação do Stable Matching Problem.
Como estamos dando preferência para as crianças, o algoritmo funciona assim:
Enquanto houver uma criança sem lobo, que ainda não tiver percorrido toda a sua lista de lobos, tentar associar esta criança com o melhor lobo possível. Se este lobo estiver livre, associa-se eles, se não, confere-se se a preferência do lobo por esta criança for maior do que a preferência pela criança com que ele está associado atualmente. Se sim, a criança com que o lobo está associado se torna livre, e a criança atual se associa com este lobo.
</p>

<ul class="org-ul">
<li>Complexidade: De acordo com a Wikipedia, a complexidade é de
\(O(n^2)\). <a href="https://en.wikipedia.org/wiki/Stable_marriage_problem">link</a></li>
</ul>
</div>
</div>


<div id="outline-container-orge2ee33d" class="outline-2">
<h2 id="orge2ee33d"><span class="section-number-2">55</span> LA 7580 Forever Young</h2>
<div class="outline-text-2" id="text-55">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
  Aplicando força bruta nos casos de exemplo, dá pra ver que conforme a
base aumenta, o número \(y\) nessa base aparenta ser cada vez maior.
A minha solução foi aplicar uma busca binária pra encontrar a maior
base, em que o valor que ela gera confertendo \(y\) fosse o menor
possível, respeitando que seja menor ou igual a \(l\). Então, eu fiz uma
função recursiva, que pega um intervalo de bases e uma posição \(p\) no
número convertido, e para cada dígito \(d\) de 0 até 9, faz outra busca
binária pra encontrar o intervalo das bases em que o dígito na posição
\(p\) é igual a \(d\), então chama novamente essa função com este intervalo
e a próxima posição. A função para quando a posição fica maior do que o
maior comprimento de número possível (19).
</p>

<ul class="org-ul">
<li>Complexidade: Encontrar a base máxima: \(O(\log_2(n))\). A complexidade
da recursão: \(O(19 \cdot 10 \cdot \log_2(n))\). Aqui o \(n\) é o intervalo total
das bases, no pior caso \([2, 10^{18}]\).</li>
</ul>
</div>
</div>

<div id="outline-container-orgb0a6e02" class="outline-2">
<h2 id="orgb0a6e02"><span class="section-number-2">56</span> CF 670D{1, 2} Magic Powder</h2>
<div class="outline-text-2" id="text-56">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
As duas versões do problema podem ser resolvidas usando uma busca
binária para encontrar a quantidade máxima de cookies que é possível
produzir. Iniciando a busca com o intervalo de 0 até um valor maior que
todas as respostas possíveis, como \(10^{10}\). A cada iteração da busca,
testando se é possível produzir a quantidade média do intervalo atual
com os ingredientes iniciais, adicionando, se necessário, o pó
especial. Se for possível fazer isto usando uma quantidade de pó
especial menor ou igual a \(k\), então, este ponto médio é uma resposta
candidata, e corto a metade menor do intervalo, caso contrário, corto a
metade de cima do intervalo e procuro por uma quantidade menor de
cookies.
</p>

<p>
A complexidade da busca é \(O(\log_2(m))\), onde m é o tamanho do intervalo
inicial, como eu usei um sempre o valor \(10^{10}\), isso é mais ou
menos 32. A complexidade do teste em cada iteração é linear e m \(n\).
</p>

<ul class="org-ul">
<li>Complexidade: \(O(n\log_2(n))\).</li>
</ul>
</div>
</div>

<div id="outline-container-org60bff93" class="outline-2">
<h2 id="org60bff93"><span class="section-number-2">57</span> URI 2036 Efeito Dominó</h2>
<div class="outline-text-2" id="text-57">
<blockquote>
<p>
<i>Dicas escritas por Leonardo Blanger.</i>
</p>
</blockquote>

<p>
Dá pra resolver com uma PD iterativa, onde cada estado é um par (peca, pos),
sendo que a posição representa a posição da peça anterior. Pra cada estado,
tentar colocar a peça atual em cada posição de [posicao, posicao+H].
Se tentar percorrer todas as posições possíveis para cada peça, vai dar TLE,
então para cada peça, é preciso fazer uma poda, tentando só as posições onde
a peça pode ficar, sem que isto viole as distâncias de antes e depois.
</p>

<ul class="org-ul">
<li>Complexidade: \(O(N*L*H)\) menos o que dá pra economizar com a poda, onde L é o tamanho total da sequências (soma de todos os Ds).</li>
</ul>
</div>
</div>


<div id="outline-container-orge47a13d" class="outline-2">
<h2 id="orge47a13d"><span class="section-number-2">58</span> URI 2351 Hotel Rewards</h2>
<div class="outline-text-2" id="text-58">
<blockquote>
<p>
<i>Dicas escritas por João Paulo Castilho.</i>
</p>
</blockquote>

<p>
Primeiro vamos analisar o seguinte: eu sempre preciso pagar por todos
os hotéis até \(K\). Se eu começar a indexar os hotéis por \(0\), o
primeiro hotel que eu posso não-pegar é o exatamente no índice
\(K\). Isso não vale somente para o hotel no índice \(K\), mas sim para
todos os seus múltiplos, ou seja, sempre no MÍNIMO, a partir deles eu
posso ter mais um hotel grátis. Por exemplo, com \(K = 2\), no índice 0 e
1, terei que pagar pelo hotel, no índice 2 ganharei mais um ticket, e a
partir do índice 4 ganharei outro e assim por diante. A solução,
portanto, consiste em uma varredura linear no vetor, de trás para
frente, colocando os valores em uma file de prioridades, do maior para
o menor. Toda vez que eu chegar em um múltiplo de \(K\), quer dizer que a
partir dessa posição eu poderei ter um ticket a mais do que das
posições pra trás, então tudo que eu tenho que fazer é tirar o primeiro
hotel que está na fila de prioridades. Fazendo isso até \(i = 0\), temos
na fila os hotéis que deverão ser pagos.
</p>

<ul class="org-ul">
<li>Comlexidade: \(O(N)\) para percorrer o vetor e $O(log(N)) para cada
inserção na heap.</li>
</ul>
</div>
</div>

<div id="outline-container-org13acbde" class="outline-2">
<h2 id="org13acbde"><span class="section-number-2">59</span> URI 2349 Farm Robot</h2>
<div class="outline-text-2" id="text-59">
<blockquote>
<p>
<i>Dicas escritas por Felipe Chabatura.</i>
</p>
</blockquote>

<p>
O problema pode ser facilmente resolvido simulando os movimentos do robô e contando quantas vezes
ele passa pela estação perto da área devastada. Os únicos cuidados especiais a serem tomados são
o de atualizar corretamente a posição do robô quando ele se encontra na posição \(N\) e avança uma
posição no sentido horário (ou na posição \(1\) e avança no sentido anti-horário) e o de considerar o caso
em que o robô já começa na estação próxima a área devastada.
</p>

<p>
-Complexidade: \(O(N)\), cada movimento do robô só é processado uma vez.
</p>
</div>
</div>

<div id="outline-container-org3bde193" class="outline-2">
<h2 id="org3bde193"><span class="section-number-2">60</span> URI 1034 Ice Statues Festival</h2>
<div class="outline-text-2" id="text-60">
<blockquote>
<p>
<i>Dicas escritas por João Paulo Castilho.</i>
</p>
</blockquote>

<p>
<a href="http://wiki.icmc.usp.br/images/1/1a/PD1.pdf">PD USP</a> Explica uma
maneira de resolver o problema do troco de forma iterativa, com uma PD.
Para resolver o problema, basta iterar sobre todos os cubos de gelo
possível, e a partir dele ir atualizando a menor solução possível com um
iterador \(j\) (\(j = cubo[i] : m\)), onde \(PD[j] = min(PD[j], PD[j -
cubo[i]] + 1)\). No final, o valor contido em \(PD[m]\) será ótimo.
</p>

<p>
PS: é óbvio que inicialmente \(PD[0] = 0\) e os demais indices até \(m\) são
inicializados com infinito.
</p>

<p>
-Complexidade: \(O(m)\) em espaço e \(O(n*m)\) em tempo.
</p>
</div>
</div>

<div id="outline-container-orgdf0a60c" class="outline-2">
<h2 id="orgdf0a60c"><span class="section-number-2">61</span> URI 1152 e UVa 11631 Dark Roads</h2>
<div class="outline-text-2" id="text-61">
<blockquote>
<p>
<i>Dicas escritas por João Paulo Castilho</i>
</p>
</blockquote>

<p>
Esse problema pode ser facilmente resolvido fazendo a MST do grafo e
subtraindo o resultado da soma de todos os pesos das arestas. Só tem que
tomar cuidado, que como têm vários casos de teste, sempre inicializar as
variáveis e o grafo corretamente.
</p>

<p>
PS: No URI minha solução não passou com Kruskal, mas no UVa, passou, mas
pelos limites do problema, deve passar tanto com Prim quanto com
Kruskal.
</p>
</div>
</div>

<div id="outline-container-org1585308" class="outline-2">
<h2 id="org1585308"><span class="section-number-2">62</span> URI 2531 Shopping in FdI</h2>
<div class="outline-text-2" id="text-62">
<blockquote>
<p>
<i>Dicas escritas por João Paulo Castilho</i>
</p>
</blockquote>

<p>
A solução é uma segment tree guardando os maiores e os menores valores
no range (usei uma struct com maior e menor). Dá pra fazer todas as
operações com custo de editar uma árvore só, não precisa de duas.
No final, quando buscar o \(rmq\), imprimir \(a[r.maior] - a[r.menor]\),
onde \(r\) é a struct retornada pelo \(rmq\).
</p>

<p>
-Complexidade: \(O(N)\) para construir a árvore. \(O(log N)\) para cada operação
de update e \(O(log N)\) para buscar pelo RMQ no intervalo \(i, j\).
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Leandro Zatesko, João Paulo Castilho</p>
<p class="date">Created: 2017-09-27 qua 01:28</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
